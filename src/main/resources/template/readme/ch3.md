# 테스트 주도 개발의 패턴
- - -
## 테스트 주도 개발 패턴

1. 테스트 한다는건 무엇을 뜻하는지?
2. 언제 테스트를 해야 하는지?
3. 테스트할 로직을 어떻게 고를지?
4. 테스트할 데이터를 어떻게 고를지?

### 테스트란?   
```테스트할 시간이 어딨어. 그냥 릴리즈해``` 이 장면에 대해서는 결과를 보장할 수 없다. 스트레스를 점점 많이 받으면 결국 실패하게 된다.
    - 스트레스를 받으면 테스트를 실행한다. 테스트를 실행하면 스트레스를 받는다.
        - 이 부분의 경우 자동화된 테스트가 존재하다면 두려운 정도를 선택할 수 있다. (스트레스 또한 줄일 수 있게 된다.)

### 격리된 테스트
```매일 아침 출근하면 지난밤 테스트 결과를 담은 종이더미가 놓여 있었다.``` 이 경험에서 두 가지의 교훈을 얻을 수 있었다.
1. 테스트가 충분히 빨라서 내가 직접, 자주 실행할 수 있게끔 만들자.
   - 내가 만든 에러를 누구보다 빠르게 잡을 수 있음.
2. 많은 양의 실패 테스트가 반드 시 양의 문제가 아닐 수 도있다.
   - 앞 부분에서 실행된 테스트가 실패한 후 그 영향으로 다음 테스트부터는 시스템이 예측 불가능한 상태에 놓이는 경우가 허다하다.
      - 그렇기에 테스트는 작은 스케일로 진행하며, 각각의 테스트와 완전히 독립적이어야 한다.

### 테스트 목록
해야하는 목록이 많아질 수록 내가 하던 일에 대한 집중력이 떨어진다. 집중력이 떨어지면 할일이 많아진다.
 - 머릿속에 있는 목록에서 임의의 항목을 무시하고 변덕스럽게 프로그래밍을 할 경우 이 악순환에서 벗어날 수 없게 된다.

### 테스트 우선
테스트는 대상이 되는 코드를 작성하기 직전에 작성하는 것이 좋다. ```스트레스 - 테스트``` 에서도 테스트가 먼저가 된다면 스트레스가 줄어 테스트도 줄게된다.

### 단언 우선
테스트를 작성할 때 단언은 가장 먼저 사용해라.
단언을 먼저 사용할 경우 작업을 단순하게 만드는 강력한 효과를 볼 수 있다. 구현에 대해 전혀 고려하지 않고 테스트만 작성할 때도 몇 가지 문제들을 한번에 해결하는 것이다.
1. 시스템을 개발할 때 무슨 일부터 하는가? 완료된 시스템은 이럴 것 이다! 라는 이야기 부터 작성한다.
2. 특정 기는을 개발할 때 무슨 일부터 하는가? 기능이 완료되면 통과할 수 있는 테스트 부터 작성한다.
3. 테스트를 개발할 때 무슨 일부터 하는가? 완료될 때 통과해야 할 단 언부터 작성한다.

### 테스트 데이터
1. 테스트를 읽을 때 쉽고 따라갈 수 있을만한 좋은 데이터를 사용해라 테스트 작성에도 청중이 존재한다.
2. 단지 데이터 값을 산발하기 위해 데이터 값을 산발하지 마라.
3. 데이터 간에 차이가 있다면 그 속에 어떤 의미가 있어야한다.
4. 만약 1과 2사이에 어떠한 개념적 차이도 없다면 1을 사용해라.
5. 여러 입력을 다루어야 한다면 테스트 또한 여러 입력을 반영해라.
6. 테스트 데이터에 대한 대안은 실제 세상에서 얻어진 실제 데이터를 사용하는 것이다.
   - 실제 실행을 통해 수집한 외부 이벤트의 결과를 이용하여 실시간 시스템을 테스트하고자 하는 경우.
   - 예전 시스템의 출력과 현재 시스템의 출력을 비교하는 경우(병렬)
   - 시뮬레이션 시스템을 리팩토링한 후 기존과 정확히 동일한 결과가 나오는지 확인하고자 하는 경우

### 명백한 데이터
테스트를 작성할 때는 컴퓨터뿐 아니라 후에 코드를 읽을 다른 사람들도 생각해야 한다.
    - 추후 자신의 코드를 보며 무슨 생각으로 이 코드를 짯는지 의문이 들 수 있다.

## 빨간 막대 패턴
이 패턴들은
 - 테스트를 언제, 어디에 작성할 것인지?
 - 테스트 작성을 언제 멈출 출지에 대한 것이다.

### 한 단계 테스트
하향식, 상향식 둘 다 모두 TDD의 프로세스를 효과적으로 설명할 수 없다. 첫째로 이와 같은 수직적 메타포는 프로그램이 시간에 따라 어떻게 변해 가는지에 대한 단순화된 시각일 뿐이다.
이보다 성장이란 단어를 보면 일종의 자기 유사성을 가진  피드백 고리를 암시하는데, 이 피드백 고리에서 환경이 프로그램에 영향을 주고 프로그램이 다시 환경에 영향을 준다.
둘째로 만약 메타포가 어떤 방향성을 가질 필요가 있다면 (상향 혹은 하향보다는) 아는 것에서 모르는 것으로 라는 방향이 유용할 것이다.

### 시작 테스트
어떤 테스트부터 시작해야 좋을지? 첫 걸음으로 현실적인 테스트를 하나 작성한다면 상당히 많은 문제를 한번에 해결해야 하는 상황이 될 것이다.
빨/초/리팩, 빨/초/리팩 주기가 짧은걸 원할 수록 정말 발견하기 쉬운 입력과 출력을 사용하여 이 테스트 시간을 짧게 줄일 수 있다.
한 단게 테스트는 시작 테스트에도 적용이 되며, 당신에게 뭔가를 가르켜 줄 수 있으면서도 빠르게 구현할 수 있는 테스트를 선택해라

### 설명 테스트
자동화된 테스트가 널리 쓰이게 하려면 테스트를 통해 설명을 요청하고 테스트를 통해 설명해야 한다.
더 넘어가 추후에는 시퀀스 다이어그램에 나타난 모든 요소들을 포함하는 테스트 케이스를 작성해 볼 수 있다.

### 학습 테스트
새로운 클래스, 새로운 메서드를 곧 바로 사용하는 것 보다는 API가 우리 예상대로 흘러가는지 확인하는 작은 테스트를 만들어서 테스트 할 수 있다.

### 또 다른 테스트
새 아이디어가 떠오르면 존중하고 맞이하되 그것이 내 주의를 흩뜨리지 않게 한다. 그 아이디어를 리스트에 적어놓고는 하던 일로 다시 돌아간다.

### 회귀 테스트
회귀 테스트란 사실 완벽한 선견지명이 있다면, 처음 코딩할 때 작성해야 하는 테스트 이다.
전체 애플리케이션 차원에서 테스트를 수행하는 것에서도 가치를 얻을 수 있다. 애플리케이션 차원의 회귀 테스트는 시스템의 사용자들이 여러분에게 정확히 무엇을 기대했으며 무엇이 잘못되었는지 말할 기회를 준다.
좀더 작은 차원에서 회귀 테스트는 당신의 테스트를 개선하는 방법이 된다.

### 휴식
지치고 고난에 빠질 때에는 휴식이다.
피로가 쌓이면 판단력이 흐려진다.
판단력이 흐려지면 피로가 쌓인다.

### 다시 하기
길을 잃었을 때에는 모든 코드를 다 지워버리고 처음부터 다시 해보자. ```다시```

### 싸구려 책상, 좋은 의자
책상보다는 진짜 진짜 좋은 의자를 사용하자...

### 테스팅 패턴
더 상세한 테스트 작성법

### 자식 테스트
지나치게 큰 테스트는 원래 테스트 케이스의 깨지는 부분에 해당하는 작은 테스트 케이스를 작성하고 그 작은 테스트 케이스가 실행되도록 하라. 그 후에 다시 원래의 큰 테스트 케이스를 추가하라.

### 모의 객체
비용이 많이 들거나 복잡한 리소스에 의존하는 객체를 테스트하려면 상수를 반환 하거나 속임수 버전의 리소스를 만들면 된다.
 - 테스트에서는 대표적으로 Mock 객체가 있다.

### 셀프 션트 ```자기가 보낸 것이 다시 자기에게 제대로 돌아오는지 확인하는 루프백 테스트와 유사한 단어```
셀프 션트 패턴은 테스트 케이스가 구현할 인터페이스를 얻기 위해 인터페이스 추출을 해야 한다. 인터페이스를 추뤃나는 것이 더 쉬운지, 존재하는 클래스를 블랙 박스로 테스트하는 것이 더 쉬운지는 개발자가 결정해야 한다.

### 로그 문자열
메세지의 호출 순서가 올바른지 검사하기 위하여 사용되며, 메세지 호출 시 그 문자열에 추가되도록 한다.
- 옵저버를 구현하고 이벤트 통보가 원하는 순서대로 발생하는지를 확인하고자 할 때 유용하다.
- 순서가 상관 없는 경우 문자열 집합을 저장하고 있다가 단언에서 집합 비교를 수행하면 된다.

### 크래시 테스트 더미
호출되면 에러가 발생할거 같은 코드는 호출하는 대신 그냥 예외를 발생시키기만 하는 특수한 객체를 만들어서 이를 호출한다.

### 깨진 테스트
혼자서 프로그래밍을 한다면 프로그래밍 세션을 마지막 테스트가 깨진 상태로 끝마치는 것이 좋다.
- 다음에 프로그래밍을 할 때 반 쪽짜리 문장을 보게 된다면 내가 그 문장을 작성할 때 무슨 생각을 했는지 떠올리게 된다. ```사람마다 다른거 아닌가?```

### 깨끗한 체크인
팀 프로그래밍을 할 때에는 프로그래밍 세션을 끝마치는게 좋다.
- 자신이 프로그래밍을 시작할 때 자신 이후에 어떤 일이 발생했는지 알 수 없다. 그렇기에 항상 모든 테스트가 돌아가는 상태로 만들어 두어야 한다.

## 초록 막대 패턴
깨진 테스트가 존재하다면 그걸 고쳐야 한다. 빨간 막대를 가능한 빨리 고쳐야 하는 조건으로 다룬다면 금새 초록 막대로 옮겨갈 수 있다는 것을 깨닫게 될 것이다.

### 가짜로 구현하기 (진짜로 만들기 전 까지만)
실패하는 테스트를 제작 후 첫 번째 구현은 상수를 반화나게 하라. 그 이후 단계적으로 상수를 변수로 사용한는 수식으로 변경한다.
가짜로 구현하기를 강력하게 만드는 두 가지 효과
- 심리학적 : 초록막대에 있는 것은 빨간 막대 상태에 있는 것과 천지 차이이며, 막대가 초록색일 경우 자기가 어디에 서 있는지 알고 있으며, 확신을 가지고 리팩토링해 갈 수 있다.
- 범위조절 : 구체적인 예에서 시작해서, 일반화하게 되면, 쓰잘데기 없는 고민으로 때 이르게 혼동하는걸 예방할 수 있으며, 다음 테스트 케이스 구현 시 이전 테스트의 작동이 보장된다는 것을 알기에 그 다음 테스트 케이스에 집중할 수 있다.

### 삼각측량
추상화 과정을 테스트 주도할 때 오로지 예가 두 개 이상일 경우에만 추상화를 하라.
추상화를 올바르게 할지 감잡기 어려울 때만 삼각측량을 사용하고 그 외의 경우 명백한 구현이나 가짜로 구현하기에 의존한다.

### 명백한 구현
가짜로 구현하기와 삼각측량의 어중간한 성질에 특별한 미덕이 있는건 아니다. 뭘 타이핑해야 할고, 그걸 할 수 있다면 재빠르게 해라

### 하나에서 여럿으로
객체 컬렉션을 다루는 연산의 경우 컬렉션 없이 구현하고 그 다음에 컬렉션을 사용한다.

## xUnit 패턴
xUnit 계열 테스팅 프레임워크를 위한 패턴

### 단언
테스트를 자동화하려면 결과를 평가하는 데 개입되는 인간의 판단을 모조리 끄집어 내야 한다.
버튼을 누르면 코드의 작동이 올바른지 검증하는 데 필요한 모든 판단은 컴퓨터가 되어야 한다. 이 것은 다음 사항을 의미한다.
- 판단 결과가 불리언 값이어야 한다. 일반적으로 참 값은 모든 테스트가 통과했음을 의미하고, 거짓 값은 뭔가 예상치 못했던 일이 발생했음을 의미한다.
- 이 불리언 값은 컴퓨터에 의해 검증되어야 한다. 보통 다양한 형태의 assert() 메서드를 호출하여 이 값을 얻어낸다.

### 픽스처
여러 테스트에서 공통적으로 사용하는 객체들을 생성할 때에는 테스트 코드에 있는 지역 변수를 인스턴스 변수로 바꾸고 setUp() 메서드를 재정의하여 이 메서드에서 인스턴스 변수들을 초기화 하도록 한다.
이와 같은 중복은 다음과 같은 장, 단점이 있다.
1. 장점
   - 복사해서 붙이는 반복 작성 시간을 줄일 수 있음
   - 인터페이스를 수동으로 변경할 필요가 있을 경우 여러 테스트를 고쳐주어야 함
2. 단점
   - 별도의 메서드로 분리하여 나머지 테스트를 작성하기 전 혹은 도중에 그 메서드가 호출된다는 점과 객체들이 어떻게 초기화 되는지 기억해야 한다.

### 외부 픽스처
각 테스트의 목적 중 하나는 테스트가 실행되기 전, 후의 외부 세계가 동일하게 유지되도록 만드는 것이다.
픽스처와 동일하게 tearDown() 메서드를 정의 후 이곳에서 자원을 해제하면 된다.

### 테스트 메서드
앞으로의 수백 수천개에 해당하는 테스트를 관리하는 방법으로 객체지향 프로그래밍 언어는 세 가지 범주의 구조 계층을 제공한다.
만약 테스트를 일반적인 소스코드처럼 작성하길 원한다면, 테스트를 위의 구조에 끼워 맞출 방법을 찾아야 한다. 
1. 모듈(자바의 패키지)
2. 클래스
3. 메서드
   1. 픽스처를 사용하기 으;해 클래스를 사용하기로 결정했다면 테스트는 동일한 픽스처를 공유하는 클래스의 메서드로 작성될 것이다.
   2. 테스트 메서드는 의미가 그대로 드러나는 코드로, 읽기 쉬워야 한다.

### 예외 테스트
예외 테스트의 정상은 예외를 잡아서 해당 예외가 발생할 경우 통과하는 테스트를 만드는 것이다.
예외가 제대로 발생하는지에 대한 테스트는 해당 코드 마지막 부분에 fail() 메서드를 호출하여 테스트가 실패했음을 알려줄 수 있다.

### 전체 테스트
모든 테스트를 한번에 실행하려면 모든 테스트 슈트에 대한 모음을 작성하면 된다.

## 디자인 패턴
